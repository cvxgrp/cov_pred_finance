# [cvxcovariance](http://www.cvxgrp.org/cov_pred_finance)

The `cvxcovariance` package
provides simple tools for creating an estimate $\hat\Sigma_t$ of the covariance $\Sigma_t$ of the $n$-dimensional return vectors $r_t$, $t=1,2,\ldots$. (Here $r_t$ is the return from $t-1$ to $t$.) The covariance predictor $\hat\Sigma_t$ is generated by blending $K$ different "expert" predictors $\hat\Sigma_t^{(1)},\ldots,\hat\Sigma_t^{(K)}$, by solving a convex optimization problem at each time step.

For a detailed description of the methodology, see the our manuscript [A Simple Method for Predicting
Covariance Matrices of Financial Returns](https://web.stanford.edu/~boyd/papers/cov_pred_finance.html) (especially Section 3).

In the simplest case the user provides an $n\times T$ pandas DataFrame
of returns $r_1,\ldots,r_T$ and $K$ half-life pairs, and gets back covariance predictors for each time
step. (The $K$ experts are computed as iterated exponentially weighted moving average (IEWMA) predictors as described in Section 2.6 of the [paper](https://web.stanford.edu/~boyd/papers/cov_pred_finance.html).) In the more general case, the user provides the $K$ expert predictors $\hat\Sigma_t^{(1)},\ldots,\hat\Sigma_t^{(K)}$, $t=1,\ldots,T$, and these are blended together by solving a convex optimization problem. In either case the result is returned as an iterator object over namedtuples: `Result = namedtuple("Result", ["time", "mean", "covariance", "weights"])`.


Note: at time $t$ the user is provided with $\Sigma_{t+1}$,
$\textit{i.e.}$, the covariance matrix for the next time step. So `Result.covariance` returns the covariance prediction for `time+1`.

## Installation
To install the package, run the following command in the terminal:

```bash
pip install cvxcovariance
```

## Usage
There are two alternative ways to use the package. The first is to use the
`covariance_combination`
 function to create a combined multiple IEWMA (CM-IEWMA) predictor. The
second is to define your own covariance predictors, via dictionaries, and pass
them to the `CovarianceCombination` class.

### CM-IEWMA
The `covariance_combination` function takes as input a pandas DataFrame of
returns and the IEWMA half-life pairs, and returns an iterator object that
iterates over the CM-IEWMA covariance predictors defined via namedtuples. Through the namedtuple you can access the `time`, `mean`, `covariance`, and `weights` attributes. `time` is the timestamp. `mean` is the estimated mean of the return at the $\textit{next}$ timestamp, $\textit{i.e.}$ `time+1`, if the user wants to estimate the mean; per default this is set to zero, which is a reasonable assumption for many financial returns. `covariance` is the estimated covariance matrix for the $\textit{next}$ timestamp, $\textit{i.e.}$ `time+1`. `weights` are the $K$ weights attributed to the experts. Here is an example:
    
```python
# Load return data
prices = pd.read_csv("resources/stock_prices.csv", index_col=0, header=0, parse_dates=True).ffill()
returns = prices.pct_change().dropna()

# Define half-life pairs, (halflife_vola, halflife_cov)
halflife_pairs = [(10, 21), (21, 63), (63, 125)]

# Loop through combination results to get predictors
covariance_predictors = {}
for predictor in covariance_combination(returns, half_life_pairs):
    # From predictor we can access predictor.time, predictor.mean (=0 here), predictor.covariance, and predictor.weights
    covariance_predictors[predictor.time] = predictor.covariance
```
Here `covariance_predictors[t]` is the covariance prediction for time $t+1$, $\textit{i.e.}$, it is uses knowledge of $r_1,\ldots,r_t$.

### General covariance combination
The `CovarianceCombination` class takes as input a pandas DataFrame of
returns and a dictionary of covariance predictors `{key: {time:
sigma}`, where `key` is the key of an expert predictor and `{time:
sigma}` is the expert predictions. For example, here we combine two EWMA covariance predictors from pandas:

```python
import panda as pd
from cvxcovariance import CovarianceCombination

# Load return data
prices = pd.read_csv("resources/stock_prices.csv", index_col=0, header=0, parse_dates=True).ffill()
returns = prices.pct_change().dropna()

# Define 21 and 63 day EWMAs as dictionaries
ewma21 = returns.ewm(halflife=21, min_periods=63).cov().dropna()
expert1 = {time: ewma21.loc[time] for time in ewma21.index.get_level_values(0).unique()}
ewma63 = returns.ewm(halflife=63, min_periods=63).cov().dropna()
expert2 = {time: ewma63.loc[time] for time in ewma63.index.get_level_values(0).unique()}

# Create expert dictionary
experts = {1: expert1, 2: expert2}

# Define the covariance combinator 
combinator = CovarianceCombination(sigmas=ewmas, returns=returns)

# Solve combination problem and loop through combination results to get predictors
covariance_predictors = {}
for predictor in combinator.solve(window=10):
    # From predictor we can access predictor.time, predictor.mean (=0 here), predictor.covariance, and predictor.weights
    covariance_predictors[predictor.time] = predictor.covariance
```
Here `covariance_predictors[t]` is the covariance prediction for time $t+1$, $\textit{i.e.}$, it is uses knowledge of $r_1,\ldots,r_t$.

## Poetry

We assume you share already the love for [Poetry](https://python-poetry.org).
Once you have installed poetry you can perform

```bash
poetry install
```

to replicate the virtual environment we have defined in pyproject.toml.

## Kernel

We install [JupyterLab](https://jupyter.org) within your new virtual
environment. Executing

```bash
./create_kernel.sh
```

constructs a dedicated
[Kernel](https://docs.jupyter.org/en/latest/projects/kernels.html) for the
project.


